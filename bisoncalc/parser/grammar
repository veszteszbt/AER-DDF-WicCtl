%baseclass-preinclude "semantics.h"
%lsp-needed

%scanner ../scanner/Scanner.h


%union
{
	std::string *str;
	int *integ;
	double *dbl;
	expression_desc *exd;
	command_list_desc *cld;
	command_desc *cd;
}

%token KEYWORD_IF
%token KEYWORD_THEN
%token KEYWORD_ELSE
%token KEYWORD_ELIF
%token KEYWORD_FI
%token KEYWORD_CASE
%token KEYWORD_IN
%token KEYWORD_ESAC
%token KEYWORD_FOR
%token KEYWORD_WHILE
%token KEYWORD_UNTIL
%token KEYWORD_DO
%token KEYWORD_DONE
%token OCURLY
%token CCURLY
%token PIPE_SYMBOL
%token ANDF_SYMBOL
%token ORF_SYMBOL
%token COMMAND_SEPARATOR
%token CASE_DELIMITER
%token BACKGROUND_COMMANDS
%token OPARENTHESIS
%token CPARENTHESIS
%token INPUT_REDIRECTION
%token INPUT_FROM_A_HERE_DOCUMENT
%token OUTPUT_CREATION
%token OUTPUT_APPEND
%token SINGLEQUOTE
%token DOUBLEQUOTE
%token DOUBLE
%token <integ> INTEGER
%token <str> IDENTIFIER
%token NEGATE
%token HEXADECIMAL

%token CONST_TRUE
%token CONST_FALSE
%token CONST_PI

%right OPERATOR_LET_BE
%left OPERATOR_AND OPERATOR_OR
%left OPERATOR_EQUAL OPERATOR_GREATER_THAN OPERATOR_LESS_THAN OPERATOR_GREATER_EQUAL OPERATOR_LESS_EQUAL OPERATOR_NOT_EQUAL
%left OPERATOR_PLUS OPERATOR_MINUS
%left OPERATOR_MULTIPLICATION OPERATOR_DIVISION OPERATOR_MODULO
%left OPERATOR_POWER
%right UNARY_MINUS

%type <exd> expression
%type <exd> input_output
%type <cld> command_list
%type <cld> command
%type <cld> else_part


%%


start:
	command_list
	{
		std::cout << "command_list" << std::endl;
	}
;


command_list:
	command_list COMMAND_SEPARATOR command
	{	
		// $$ = new command_list_desc();
		// $$->add($1);
		std::cout << "command_list COMMAND_SEPARATOR command" << std::endl;
	}
|
	command
	{
		//// $$ = new command_desc(d_loc__.first_line);
		std::cout << "command_list -> command" << std::endl;
	}
;

command:
	expression
	{
		// $$ = new command_list_desc();
		// command_desc* tempcd = new command_desc($1->get_row());
		// $$->add(tempcd);
		//delete tempcd;
		std::cout << "command -> expression" << std::endl;
	}
|
	OCURLY command_list CCURLY
	{
		std::cout << "command -> OCURLY command_list CCURLY" << std::endl;
	}
|
	KEYWORD_FOR expression KEYWORD_DO command_list KEYWORD_DONE
	{
		/*if ($2->expr_type != u_integer) // az expression NAME (porkmail szerint)
		{
			std::cerr << "Incorrect condition in For loop" << std::endl;
			exit(1);
		}
		else
		{
			// $$ = new command_desc($2->row);
		}*/
		std::cout << "command -> KEYWORD_FOR expression KEYWORD_DO command_list KEYWORD_DONE" << std::endl;
	}
|
	KEYWORD_FOR expression KEYWORD_IN expression KEYWORD_DO command_list KEYWORD_DONE
	{
		// command_desc* tempcd = new for_in_desc($2, $4, $6);
		// $$ = new command_list_desc();
		// $$->add(tempcd);
		//delete tempcd;
		std::cout << "command -> KEYWORD_FOR IDENTIFIER KEYWORD_IN expression KEYWORD_DO command_list KEYWORD_DONE" << std::endl;
	}
|
	KEYWORD_FOR expression COMMAND_SEPARATOR expression COMMAND_SEPARATOR expression KEYWORD_DO command_list KEYWORD_DONE
	{
		// command_desc* tempcd = new for_3_desc($3, $5, $7, $10);
		// $$ = new command_list_desc();
		// $$->add(tempcd);
		//delete tempcd;
		std::cout << "command -> KEYWORD_FOR expression COMMAND_SEPARATOR expression COMMAND_SEPARATOR expression KEYWORD_DO command_list KEYWORD_DONE" << std::endl;
	}
|
	KEYWORD_WHILE expression KEYWORD_DO command_list KEYWORD_DONE
	{
		// command_desc* tempcd = new while_desc($2, $4);
		// $$ = new command_list_desc();
		// $$->add(tempcd);
		//delete tempcd;
		std::cout << "command -> KEYWORD_WHILE expression KEYWORD_DO command_list KEYWORD_DONE" << std::endl;
	}
|
	KEYWORD_UNTIL expression KEYWORD_DO command_list KEYWORD_DONE
	{
		// command_desc* tempcd = new until_desc($2, $4);
		// $$ = new command_list_desc();
		// $$->add(tempcd);
		//delete tempcd;
		std::cout << "command -> KEYWORD_UNTIL expression KEYWORD_DO command_list KEYWORD_DONE" << std::endl;
	}
|
	KEYWORD_CASE expression KEYWORD_IN caseparts KEYWORD_ESAC
	{
		std::cout << "command -> KEYWORD_CASE expression KEYWORD_IN caseparts KEYWORD_ESAC" << std::endl;
	}
|
	KEYWORD_IF expression KEYWORD_THEN command_list else_part KEYWORD_FI
	{
		// command_desc* tempcd = new if_desc($2, $4, $5);
		// $$ = new command_list_desc();
		// $$->add(tempcd);
		//delete tempcd;
		std::cout << "command -> KEYWORD_IF expression KEYWORD_THEN command_list else_part KEYWORD_FI" << std::endl;
	}
;


expression:
	OPARENTHESIS expression CPARENTHESIS
	{
		$$ = new expr_par(d_loc__.first_line, $2);
		std::cout << "expression -> OPARENTHESIS expression CPARENTHESIS" << std::endl;
	}
|
	IDENTIFIER OPERATOR_LET_BE expression
	{
		$$ = new expr_asg(d_loc__.first_line, $1, $3);
		std::cout << "expression -> IDENTIFIER OPERATOR_LET_BE expression" << std::endl;
	}
|
	NEGATE expression
	{
		$$ = new expr_neg(d_loc__.first_line, $2);
		std::cout << "expression -> NEGATE expression" << std::endl;
	}
|
	expression OPERATOR_AND expression
	{
		$$ = new expr_and(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_AND expression" << std::endl;
	}
|
	expression OPERATOR_OR expression
	{
		$$ = new expr_or(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_OR expression" << std::endl;
	}
|
	expression OPERATOR_EQUAL expression
	{
		$$ = new expr_eq(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_EQUAL expression" << std::endl;
	}
|
	expression OPERATOR_NOT_EQUAL expression
	{
		$$ = new expr_neq(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_NOT_EQUAL expression" << std::endl;
	}
|
	expression OPERATOR_LESS_EQUAL expression
	{
		$$ = new expr_leq(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_LESS_EQUAL expression" << std::endl;
	}
|
	expression OPERATOR_GREATER_EQUAL expression
	{
		$$ = new expr_geq(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_GREATER_EQUAL expression" << std::endl;
	}
|
	expression OPERATOR_LESS_THAN expression
	{
		$$ = new expr_lt(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_LESS_THAN expression" << std::endl;
	}
|
	expression OPERATOR_GREATER_THAN expression
	{
		$$ = new expr_gt(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_GREATER_THAN expression" << std::endl;
	}
|
	expression OPERATOR_PLUS expression
	{
		std::cout << "dloc:" << d_loc__.first_line << std::endl;
		$$ = new expr_add(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_PLUS expression" << std::endl;
	}
|
	expression OPERATOR_MINUS expression
	{
		$$ = new expr_dif(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_MINUS expression" << std::endl;
	}
|
	expression OPERATOR_MULTIPLICATION expression
	{
		$$ = new expr_mul(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_MULTIPLICATION expression" << std::endl;
	}
|
	expression OPERATOR_DIVISION expression
	{
		$$ = new expr_div(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_DIVISION expression" << std::endl;
	}
|
	expression OPERATOR_MODULO expression
	{
		$$ = new expr_mod(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_MODULO expression" << std::endl;
	}
|
	expression OPERATOR_POWER expression
	{
		$$ = new expr_pow(d_loc__.first_line,$1,$3);
		std::cout << "expression -> expression OPERATOR_POWER expression" << std::endl;
	}
|
	OPERATOR_MINUS expression %prec UNARY_MINUS
	{
		$$ = new expr_um(d_loc__.first_line,$2);
		std::cout << "expression -> OPERATOR_MINUS expression %prec UNARY_MINUS" << std::endl;
	}
|
	INTEGER
	{
		// értékre hivatkozás											std::cout << "INTEGER: " << *$1 << std::endl;
		$$ = new expression_desc(d_loc__.first_line, u_integer, *$1);
		std::cout << "expression -> INTEGER" << std::endl;
	}
|
	DOUBLE
	{
		//// $$ = d_scanner.doubleValue();
		$$ = new expression_desc(d_loc__.first_line, u_double);
		std::cout << "expression -> DOUBLE" << std::endl;
	}
|
	SINGLEQUOTE
	{
		//// $$ = d_scanner.matched();
		$$ = new expression_desc(d_loc__.first_line, u_string);
		std::cout << "expression -> SINGLEQUOTE" << std::endl;
	}
|
	DOUBLEQUOTE
	{
		//$ = d_scanner.matched();
		$$ = new expression_desc(d_loc__.first_line, u_string);
		std::cout << "expression -> DOUBLEQUOTE" << std::endl;
	}
|
	HEXADECIMAL
	{
		std::cout << "expression -> HEXADECIMAL" << std::endl;
	}
|
	input_output
	{
		std::cout << "expression -> input_output" << std::endl;
	}
|
	IDENTIFIER
	{
		//const char *x = $1;
		//if (!x)
		//{
		//	std::cout << "x null" << std::endl;
		//}
		/*if( symbol_table.count( *$1) == 0)
		{
			std::cerr << d_loc__.first_line << ": " << *$1 << "variable doesn't have a value yet." << std::endl;

		}
		else
		{
			variable_desc vd = symbol_table[*$1];
			//switch(vd.var_type)
			//case(u_integer):
			//	// $$ = new expression_desc(vd.decl_row, vd.var_type, vd.intval);
			//break;
			//case(u_double):
			//	// $$ = new expression_desc(vd.decl_row, vd.var_type, vd.doubleval);
			//break;
			//case(u_string):
			//	// $$ = new expression_desc(vd.decl_row, vd.var_type, vd.stringval);
			//break;
			//default:
			//	std::cout << "Cannot determine " << $1 << "'s type." << std::endl;
		}*/
		std::cout << "expression -> IDENTIFIER" << std::endl;
	}
|
	CONST_TRUE
	{
		//// $$ = 0;

		//// $$ = new expression_desc(value=0)
		$$ = new expression_desc(d_loc__.first_line, u_integer, 1);
		std::cout << "expression -> CONST_TRUE" << std::endl;
	}
|
	CONST_FALSE
	{
		//// $$ = 1;
		$$ = new expression_desc(d_loc__.first_line, u_integer, 0);
		std::cout << "expression -> CONST_FALSE" << std::endl;

	}
|
	CONST_PI
	{
		constexpr double Pi = acos(-1);
		//// $$ = Pi;
		$$ = new expression_desc(d_loc__.first_line, u_double, Pi);
		std::cout << "expression -> CONST_Pi" << std::endl;

	}
;



input_output:
	OUTPUT_CREATION IDENTIFIER
	{
		std::cout << "input_output -> OUTPUT_CREATION IDENTIFIER" << std::endl;
	}
|
	INPUT_REDIRECTION IDENTIFIER
	{
		std::cout << "input_output -> INPUT_REDIRECTION IDENTIFIER" << std::endl;
	}
|
	INPUT_FROM_A_HERE_DOCUMENT IDENTIFIER
	{
		std::cout << "input_output -> INPUT_FROM_A_HERE_DOCUMENT IDENTIFIER" << std::endl;
	}
|
	OUTPUT_APPEND IDENTIFIER
	{
		std::cout << "input_output -> OUTPUT_APPEND IDENTIFIER" << std::endl;
	}
;

	
	

	
caseparts:
	case_part caseparts2
	{
		std::cout << "caseparts -> case_part caseparts2" << std::endl;
	}
;

caseparts2:
	case_part caseparts2
	{
		std::cout << "caseparts2 -> case_part caseparts2" << std::endl;
	}
|
	//empty
	{
		std::cout << "caseparts2 -> empty" << std::endl;
	}
;

case_part:
	pattern CPARENTHESIS command_list CASE_DELIMITER
	{
		std::cout << "case_part -> pattern CPARENTHESIS command_list CASE_DELIMITER" << std::endl;
	}
;

else_part:
	KEYWORD_ELSE command_list
	{
		//// $$ = new command_desc($2->row);
		// $$ = new command_list_desc();
		// $$->add($2);
		std::cout << "else_part -> KEYWORD_ELSE command_list" << std::endl;
	}
|
	//empty
	{
		//// $$ = new command_desc(d_loc__.first_line);
		std::cout << "else_part -> empty" << std::endl;
	}
;

pattern:
	IDENTIFIER
	{
		std::cout << "pattern -> IDENTIFIER" << std::endl;
	}
|
	pattern PIPE_SYMBOL IDENTIFIER
	{
		std::cout << "pattern -> pattern PIPE_SYMBOL IDENTIFIER" << std::endl;
	}
;
	
	