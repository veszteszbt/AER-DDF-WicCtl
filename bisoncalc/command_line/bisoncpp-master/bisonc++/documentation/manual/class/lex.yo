    The tt(int lex()) private member function is called by the tt(parse())
member to obtain the next lexical token. By default it is not implemented, but
the tt(%scanner) directive (see section ref(SCANNER)) may be used to
pre-implement a standard interface to a lexical analyzer.

    The tt(lex()) member function interfaces to the lexical scanner, and it is
expected to return the next token produced by the lexical scanner. This token
may either be a plain character or it may be one of the symbolic tokens
defined in the bf(Parser::Tokens) enumeration. Any zero or negative token
value is interpreted as `end of input', causing tt(parse()) to return.

    The tt(lex()) member function may be implemented in various ways:
    itemization(
    it() By default, if the tt(--scanner) option or tt(%scanner) directive is
provided bic() assumes that it should interface to the scanner generated by
bf(flexc++)(1). In this case, the scanner token function is called as
        verb(
    d_scanner.lex()
        )
    and the scanner's matched text function is called as 
        verb(
    d_scanner.matched()
        )


    it() tt(lex()) may itself implement a lexical analyzer (a
em(scanner)). This may actually be a useful option when the input offered to
the program using b()'s parser class is not overly complex. This approach was
used when implementing the earlier examples (see sections ref(RPNLEX) and 
ref(MFLEX)).

    it() tt(lex()) may call a external function or member function of class
implementing a lexical scanner, and return the information offered by this
external function. When using a class, an object of that class could also be
defined as additional data member of the parser (see the next
alternative). This approach can be followed when generating a lexical scanner
from a lexical scanner generating tool like bf(lex)(1) or bf(flex++)(1). The
latter program allows its users to generate a scanner em(class).

    it() To interface bic() to code generated by bf(flex)(1), the tt(--flex)
option or tt(%flex) directive can be used in combination with the
tt(--scanner) directive or tt(%scanner) option. In this case the scanner token
function is called as 
        verb(
    d_scanner.yylex()
        )
    and the scanner's matched text function is called as 
        verb(
    d_scanner.YYText()
        )
    )


