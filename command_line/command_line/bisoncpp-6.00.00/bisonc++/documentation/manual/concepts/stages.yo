The design process when using b(), from grammar specification
to a working compiler or interpreter, consists of the following steps:
    itemization(
    it() First a grammar is apecified in a form recognized by b() (see
chapter ref(GRAMMARFILES)).

    For each grammatical rule in the language, an action can be defined that
is performed when a production rule has completely been recognized. The action
is described using bf(C++) statements.
    it() Run b() on the grammar, producing the parser class and several of its
member functions (among which the parsing member function `tt(parse)').
    it() Design a lexical scanner to process input, passing tokens to the
parser. The lexical scanner may be written by hand (see section ref(LEX)), but
it can also be produced by, e.g., bf(flex)(1) (using bf(flex)(1) is not
covered in this manual).
    it() All the parser's members (except for the member tt(parse()) and its
support functions) 1must be implemented by the programmer. Commonly additional
member functions are also be declared in the parser class' header.  At the
very least the member tt(int lex()), calling the lexecal scanner to produce
the next available token, em(must) be implemented (although a standardized
implementation can optionallu be generated by b()). The member tt(lex) is
called by tt(parse's) support functions to obtain the next available
token. The member function tt(void error(char const *msg)) may also be
re-implemented by the programmer (a simple in-line implementation is
provided by default). The member function tt(error) is called when
tt(parse) encounters (syntactic) errors.
    it() The parser can now be used in a program. A simple example would
be: 
        verb(
    int main()
    {
        Parser parser;
        return parser.parse();
    }
        )
    )
    Once the program's source files are available, they must be compiled and
linked togrether, producing the  final program.
